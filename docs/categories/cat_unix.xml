<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>凡云的博客 (文章分类：UNIX)</title><link>http://blog.runxcode.com/</link><description></description><atom:link href="http://blog.runxcode.com/categories/cat_unix.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><lastBuildDate>Tue, 05 Sep 2017 11:26:21 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>repo sync 加速</title><link>http://blog.runxcode.com/posts/speed-up-the-downloading-of-sdk.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;p&gt;项目是用 repo 来管理 SDK，随着 SDK 中包含的仓库越来越多，以及单个仓库的体积越来越大，下载 SDK 的时间越来越长，目前已经超过了 15 分钟。
有没有办法加速 SDK 的下载？ 答案是有的，就是利用  repo 命令的 --reference 参数，可以将下载时间优化到 1 分钟左右。&lt;/p&gt;
&lt;p&gt;该方法需要先创建本地 SDK mirror，然后在执行 repo init 命令的时候设定 --reference 参数。
SDK mirror 只需要创建一次，未来 sync 代码时可以重复使用。&lt;/p&gt;
&lt;p&gt;创建 SDK mirror:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_888dc436f2464f1b853d8f759a6b6184-1"&gt;&lt;/a&gt;mkdir sdk_repo_mirror
&lt;a name="rest_code_888dc436f2464f1b853d8f759a6b6184-2"&gt;&lt;/a&gt;cd sdk_repo_mirror
&lt;a name="rest_code_888dc436f2464f1b853d8f759a6b6184-3"&gt;&lt;/a&gt;repo init -u ssh://YOUR_ACOUNT@GERRIT_HOST/manifest --mirror
&lt;a name="rest_code_888dc436f2464f1b853d8f759a6b6184-4"&gt;&lt;/a&gt;repo sync --no-tags;
&lt;/pre&gt;&lt;p&gt;Download SDK Source:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_45aa9f0690ed40cb9682efc2ade65ae0-1"&gt;&lt;/a&gt;mkdir sdk_work
&lt;a name="rest_code_45aa9f0690ed40cb9682efc2ade65ae0-2"&gt;&lt;/a&gt;cd sdk_work
&lt;a name="rest_code_45aa9f0690ed40cb9682efc2ade65ae0-3"&gt;&lt;/a&gt;repo init -u ssh://YOUR_ACOUNT@GERRIT_HOST/manifest --reference=YOUR_SDK_MIRROR_PATH
&lt;a name="rest_code_45aa9f0690ed40cb9682efc2ade65ae0-4"&gt;&lt;/a&gt;repo sync
&lt;/pre&gt;&lt;p&gt;repo 仓库中的注释:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_da63dd18e8b94cd7a99d5471a33294b5-1"&gt;&lt;/a&gt;The --reference option can be used to point to a directory that has the content of a --mirror sync. This will make the working
&lt;a name="rest_code_da63dd18e8b94cd7a99d5471a33294b5-2"&gt;&lt;/a&gt;directory use as much data as possible from the local reference directory when fetching from the server. This will make the sync
&lt;a name="rest_code_da63dd18e8b94cd7a99d5471a33294b5-3"&gt;&lt;/a&gt;go a lot faster by reducing data traffic on the network.
&lt;/pre&gt;&lt;/div&gt;</description><category>git</category><category>repo</category><guid>http://blog.runxcode.com/posts/speed-up-the-downloading-of-sdk.html</guid><pubDate>Tue, 05 Sep 2017 07:32:28 GMT</pubDate></item><item><title>从一个死锁问题说起</title><link>http://blog.runxcode.com/posts/talking-from-dead-lock.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;p&gt;碰到一个死锁问题，A 进程一直持有锁。&lt;/p&gt;
&lt;p&gt;加锁和解锁代码如下：&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-1"&gt;&lt;/a&gt;fd = open(PATH, O_RDRW);
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-2"&gt;&lt;/a&gt;if (fd &amp;lt; 0)
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-3"&gt;&lt;/a&gt;        goto out;
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-4"&gt;&lt;/a&gt;ret = flock(fd, LOCK_SH);
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-5"&gt;&lt;/a&gt;if (ret &amp;lt; 0)
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-6"&gt;&lt;/a&gt;        goto out;
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-7"&gt;&lt;/a&gt;
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-8"&gt;&lt;/a&gt;/* do something */
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-9"&gt;&lt;/a&gt;
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-10"&gt;&lt;/a&gt;out:
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-11"&gt;&lt;/a&gt;        if (fd &amp;gt; 0) {
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-12"&gt;&lt;/a&gt;                flock(fd, LOCK_UN);
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-13"&gt;&lt;/a&gt;                close(fd);
&lt;a name="rest_code_a342bf649ecd46c0b1ae67b50d8a39ae-14"&gt;&lt;/a&gt;        }
&lt;/pre&gt;&lt;p&gt;追送代码发现，出现了加锁而没有释放锁的情况；唯一的可能性就是 fd &amp;gt; 0 不成立。
但加锁成功，说明 fd 不会小于 0；所以 fd == 0.&lt;/p&gt;
&lt;p&gt;为什么？ fd 是由系统调用 open 返回的，通常情况是 &amp;gt; 0 的；内核根据进程打开文件的记录返回没有使用的
值；如果 fd 为 0，说明之前 0 是空着的；但我们知道 0 通常代表着 标准输入，可能情况就是有人把标注输入
close 掉了。daemon 程序通常会将 0， 1，2 重新定向于 /dev/null, 但我们并没有这样处理。
通过 proc 文件系统查看 fd 的使用情况。&lt;/p&gt;
&lt;p&gt;正常情况：&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_a38d3e25a822468c87624e910369a65d-1"&gt;&lt;/a&gt;# ls -lh /proc/1845/fd/*
&lt;a name="rest_code_a38d3e25a822468c87624e910369a65d-2"&gt;&lt;/a&gt;lr-x------    1 root     root          64 Oct 25 17:50 1845/fd/0 -&amp;gt; /var/console
&lt;a name="rest_code_a38d3e25a822468c87624e910369a65d-3"&gt;&lt;/a&gt;lrwx------    1 root     root          64 Oct 25 18:49 1845/fd/1 -&amp;gt; /dev/console
&lt;a name="rest_code_a38d3e25a822468c87624e910369a65d-4"&gt;&lt;/a&gt;lrwx------    1 root     root          64 Oct 25 18:49 1845/fd/2 -&amp;gt; /dev/console
&lt;/pre&gt;&lt;p&gt;异常情况：&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_755cb63e00284310987b304a56173740-1"&gt;&lt;/a&gt;# ls -lh /proc/1845/fd/*
&lt;a name="rest_code_755cb63e00284310987b304a56173740-2"&gt;&lt;/a&gt;lr-x------    1 root     root          64 Oct 25 17:50 1845/fd/0 -&amp;gt; /var/conf/myfile
&lt;a name="rest_code_755cb63e00284310987b304a56173740-3"&gt;&lt;/a&gt;lrwx------    1 root     root          64 Oct 25 18:49 1845/fd/1 -&amp;gt; /dev/console
&lt;a name="rest_code_755cb63e00284310987b304a56173740-4"&gt;&lt;/a&gt;lrwx------    1 root     root          64 Oct 25 18:49 1845/fd/2 -&amp;gt; /dev/console
&lt;/pre&gt;&lt;p&gt;很明显标准输入被 close 了，然后进程重新 open 文件时就得到了值为 0 的 fd.&lt;/p&gt;
&lt;p&gt;谁关闭了标准输入？ 为什么？&lt;/p&gt;
&lt;p&gt;有了方向很快就查到了元凶。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们知道 Linux 同时支持 POSIX 标准 和 System V 标准的 IPC 机制。 项目中使用了 Message queue 的 IPC 方法，但我们混用了两种机制；在获取 IPC handle 的时候使用了 System V 标准(msgget)；但释放 IPC handle 的时候使用了 POSIX 标准 (mq_close). 问题是 msgget 的拿到的值有很大概率为 0；mq_close(0) 会将 0 号 fd close 掉，导致 0 号 fd 重新进入了分配池。&lt;/strong&gt;&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;两点结论:&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic simple"&gt;
&lt;li&gt;系统调用 open/create 的返回值是有可能为 0 的&lt;/li&gt;
&lt;li&gt;POSIX 标准和 System V 标准的 系统调用不能混合使用&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;&lt;/div&gt;</description><category>System Call</category><category>UNIX</category><guid>http://blog.runxcode.com/posts/talking-from-dead-lock.html</guid><pubDate>Tue, 25 Oct 2016 10:28:11 GMT</pubDate></item><item><title>FAT32 文件系统时间戳问题</title><link>http://blog.runxcode.com/posts/file-time-at-fat32.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;p&gt;最近遇到一个文件创建时间显示异常问题。嵌入系统中 SD 的文件系统默认选择 vfat，
就是 FAT32；在嵌入式系统中查看文件的创建时间是正常的，但如果将 SD 卡插入到 PC 机
上面，无论是 Ubuntu 还是 Windows，文件的创建时间都会显示异常，比实际创建时间早8个小时。&lt;/p&gt;
&lt;p&gt;嵌入式系统上的时区为东8区（北京时间）；其他应用获取时间和日期都正常。开始怀疑是 vfat 的问题；
但在 Ubuntu 14.04 上测试没有遇到问题。&lt;/p&gt;
&lt;p&gt;有同事反应说他们之前也碰到过类似的问题，解决办法是调用 &lt;em&gt;settimeofday&lt;/em&gt; 时提供时区参数。&lt;/p&gt;
&lt;p&gt;查阅 settimeofday 的在线手册，发现有这样一段话：&lt;/p&gt;
&lt;p&gt;Under  Linux  there are some peculiar "warp clock" semantics associated with the settimeofday() system call if on the
very first call (after booting) that has a non-NULL tz argument, the tv argument is NULL and the tz_minuteswest field
is  nonzero.   (The tz_dsttime field should be zero for this case.)  In such a case it is assumed that the CMOS clock
is on local time, and that it has to be incremented by this amount to get UTC system time.  No doubt it is a bad idea
to use this feature&lt;/p&gt;
&lt;p&gt;查看内核中关于时间的代码，发现 CMOS Clock 存储的是本地时间；而内核对此一无所知。因此需要某种手段来告知内核。内核为此还
定义了一个全局的变量 &lt;em&gt;sys_tz&lt;/em&gt; 来记录时区信息。在呼叫 &lt;em&gt;settimeofday&lt;/em&gt; 时，如果时区参数不为空，内核就会修改 &lt;em&gt;sys_tz&lt;/em&gt; 变量。&lt;/p&gt;
&lt;p&gt;因此怀疑 FAT32 中记录的文件创建时间是 locale time，不是 UTC 时间。查阅 FAT32 的代码发现，在创建文件节点时，会呼叫
&lt;em&gt;fat_time_unix2fat&lt;/em&gt; 时将 UTC 时间转换为本地时间。在转换的过程中，使用了 &lt;em&gt;sys_tz&lt;/em&gt; 保存的时区信息或者
挂载文件系统时指定的时区信息。&lt;/p&gt;
&lt;p&gt;内核也建议在系统上电之后，应尽快设置 &lt;em&gt;sys_tz&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;解决方案：系统启动后，利用 &lt;em&gt;hwclock&lt;/em&gt; 设置内核的 &lt;em&gt;sys_tz&lt;/em&gt; 变量。&lt;/p&gt;&lt;/div&gt;</description><category>File System</category><category>UNIX</category><guid>http://blog.runxcode.com/posts/file-time-at-fat32.html</guid><pubDate>Wed, 27 Jul 2016 11:56:50 GMT</pubDate></item><item><title>inotify 失效问题</title><link>http://blog.runxcode.com/posts/inotify-and-sendfile.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;p&gt;inotify 子系统可以用来监视文件系统，包括文件后者目录的创建，修改，删除等等。
但如果通过 sendfile 对文件作出修改，inotify 就会监测不到对应的事件。&lt;/p&gt;</description><category>IO</category><category>UNIX</category><guid>http://blog.runxcode.com/posts/inotify-and-sendfile.html</guid><pubDate>Thu, 03 Mar 2016 13:02:16 GMT</pubDate></item><item><title>Stable Ubuntu 14.04</title><link>http://blog.runxcode.com/posts/ubuntu.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;p&gt;I find that my Ubuntu 14.04 had run 65 days without reboot.
That's good.&lt;/p&gt;
&lt;p&gt;$ uptime&lt;/p&gt;
&lt;p&gt;18:03:05 up 65 days, 8:40, 5 users, load average: 0.15, 0.12, 0.14&lt;/p&gt;&lt;/div&gt;</description><category>UNIX</category><guid>http://blog.runxcode.com/posts/ubuntu.html</guid><pubDate>Wed, 29 Jul 2015 12:19:23 GMT</pubDate></item><item><title>ftok 陷阱</title><link>http://blog.runxcode.com/posts/ftok.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;p&gt;最近手上的项目出现了一个很严重的bug, 系统的message queue 资源被消耗完毕; 在创建 message queue
时提示已超出系统的资源限制(ENOSPC); 通过msgctl 查看系统上的 message queue 数目, 的确超出了系统的
限制(&lt;em&gt;/proc/sys/kernel/msgmni&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;System IPC (message queue, share memory 等等) 在创建时, 必须指定一个 KEY 值, 这个 KEY 来自于 ftok.&lt;/p&gt;
&lt;p&gt;debug 发现, 调用ftok产生的 KEY, 每次都不一样.&lt;/p&gt;
&lt;p&gt;查看fotk的 source code(glibc 2.20)&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-1"&gt;&lt;/a&gt;key_t ftok (const char *pathname, int proj_id) {
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-2"&gt;&lt;/a&gt;        struct stat64 st;
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-3"&gt;&lt;/a&gt;        key_t key;
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-4"&gt;&lt;/a&gt;
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-5"&gt;&lt;/a&gt;        if (__xstat64 (_STAT_VER, pathname, &amp;amp;st) &amp;lt; 0)
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-6"&gt;&lt;/a&gt;                return (key_t) -1;
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-7"&gt;&lt;/a&gt;
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-8"&gt;&lt;/a&gt;        key = ((st.st_ino &amp;amp; 0xffff) | ((st.st_dev &amp;amp; 0xff) &amp;lt;&amp;lt; 16)
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-9"&gt;&lt;/a&gt;                | ((proj_id &amp;amp; 0xff) &amp;lt;&amp;lt; 24));
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-10"&gt;&lt;/a&gt;
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-11"&gt;&lt;/a&gt;        return key;
&lt;a name="rest_code_b6f99ca06dc74d4a8a8a4163cfc30200-12"&gt;&lt;/a&gt;}
&lt;/pre&gt;&lt;p&gt;这样看, KEY 值与文件系统所在的 device id 和 文件节点号 有关, 如果 &lt;em&gt;pathname&lt;/em&gt; 没有被删除, 则key值应该维持不变.&lt;/p&gt;
&lt;p&gt;最终发现, &lt;em&gt;pathname&lt;/em&gt; 在出错处理时被删除, 从而导致 KEY 值不固定.&lt;/p&gt;
&lt;p&gt;实验发现, 如果 &lt;em&gt;pathname&lt;/em&gt; 位于真实的文件系统, 比如EXT4, 删除后重新创建 &lt;em&gt;pathname&lt;/em&gt; , &lt;em&gt;st_ino&lt;/em&gt; 和 &lt;em&gt;st_dev&lt;/em&gt; 不一定发生变化;
但如果 &lt;em&gt;pathname&lt;/em&gt; 位于 ramfs 或者 tmpfs, 删除后重新创建, &lt;em&gt;st_ino&lt;/em&gt; 一定会改变. 所以, &lt;em&gt;pathname&lt;/em&gt; 所在的文件系统可能会影响
KEY 的产生. (笔者所在的项目中, &lt;em&gt;pathname&lt;/em&gt; 位于 ramfs)&lt;/p&gt;
&lt;p&gt;另外, 在 glibc 2.20 的 ftok 实现中, 只是使用了inode number 的低 16 位, 如果文件系统中包含大量的文件, 就会存在两个文件的 inode_number
低 16 位 相同; 此时, 这两个文件对应的 KEY 值 就会相同, 违背了 不同的文件产生不同的 KEY 的原则.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Linux programmer's Manual&lt;/em&gt; 是这样说的:&lt;/p&gt;
&lt;pre class="code text"&gt;&lt;a name="rest_code_36bce8bc206e47ac97481683511d6c24-1"&gt;&lt;/a&gt;Of course no guarantee can be given that the resulting key_t is unique.
&lt;a name="rest_code_36bce8bc206e47ac97481683511d6c24-2"&gt;&lt;/a&gt;Typically, a best effort attempt combines the given proj_id byte,
&lt;a name="rest_code_36bce8bc206e47ac97481683511d6c24-3"&gt;&lt;/a&gt;the lower 16  bits  of the inode number, and the lower 8 bits of
&lt;a name="rest_code_36bce8bc206e47ac97481683511d6c24-4"&gt;&lt;/a&gt;the device number into a 32-bit result.  Collisions may easily happen,
&lt;a name="rest_code_36bce8bc206e47ac97481683511d6c24-5"&gt;&lt;/a&gt;for example between files on /dev/hda1 and files on /dev/sda1.
&lt;/pre&gt;&lt;/div&gt;</description><category>UNIX</category><guid>http://blog.runxcode.com/posts/ftok.html</guid><pubDate>Sat, 25 Apr 2015 11:41:13 GMT</pubDate></item></channel></rss>