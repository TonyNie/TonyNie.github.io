<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>凡云的博客 (文章分类：develop tools)</title><link>http://blog.runxcode.com/</link><description></description><atom:link href="http://blog.runxcode.com/categories/develop-tools.xml" rel="self" type="application/rss+xml"></atom:link><language>zh_cn</language><lastBuildDate>Tue, 05 Sep 2017 07:36:49 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>VirtualBox 找不到网络界面</title><link>http://blog.runxcode.com/posts/virtualbox.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;p&gt;VBox 的网络模式有 N 多种，每种都有使用场景；个人比较倾向选择 Bridge 模式，好处是虚拟机在
Host 所处的局域网是真实存在的，其他机器都可以访问。但在 Bridge 模式先，如果 ethernet 没有
插入网线，Host 和 Virtual Machine 无法互相访问（host 为 Mac OS）。&lt;/p&gt;
&lt;p&gt;希望将网络模式 hostonly 也配置起来，这样在没有 ethernet 的情况下也可以 ssh 到虚拟机。但配置
网络的时候 UI 上提示没有界面可以选择。google 之，原来 hostonly 需要利用 VBoxManage 创建一个
interface 出来。&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;VBoxManage hostonlyif create&lt;/li&gt;
&lt;li&gt;VBoxManage hostonlyif ipconfig vboxnet0 --ip 192.168.56.2 --netmask 255.255.255.0&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description><category>develop tools</category><guid>http://blog.runxcode.com/posts/virtualbox.html</guid><pubDate>Fri, 01 Jul 2016 00:43:07 GMT</pubDate></item><item><title>tmux 中 ssh-agent forwarding 失效问题</title><link>http://blog.runxcode.com/posts/tmux.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;p&gt;作为程序员，我是比较懒的，对于重复性的劳动深恶痛绝。&lt;/p&gt;
&lt;p&gt;之前 byobu 和 screen 用的不怎么顺手，没有坚持下去；后来转向 tmux，经过一段时间的摸索，发现还是
蛮好用的。&lt;/p&gt;
&lt;p&gt;目前的工作模式使用一台 Mac book，ssh 到一台或者两台 Ubuntu 做开发工作，利用 tmux 打开好几个终端。
下班前做 tmux 的 detach 动作, 第二天上班重新 attach 上去。&lt;/p&gt;
&lt;p&gt;问题来了。重新 attach 后 ssh agent forwarding 就无法成功了，导致向 gerrit push 或者 fetch 的动作 fail；
无耐之下只能将 tmux session 解散，重新组织队伍。 这样无意义的重复劳动是不能接受的。&lt;/p&gt;
&lt;p&gt;阅读 tmux 的帮主手册； google 之，在 &lt;a class="reference external" href="http://unix.stackexchange.com/questions/75681/why-do-i-have-to-re-set-env-vars-in-tmux-when-i-re-attach"&gt;stackexchange&lt;/a&gt; 找到了解决方案，但觉得不够完美(存在安全风险)；&lt;/p&gt;
&lt;p&gt;又花了两个小时了解 ssh-agent forwarding 的原理和流程， 发现一篇好文章: &lt;a class="reference external" href="http://www.unixwiz.net/techtips/ssh-agent-forwarding.html"&gt;An_Illustrated_Guide_to_SSH_Agent_Forwarding&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;仔细阅读帮助手册，发现问题出在环境变量 SSH_AUTH_SOCK 上面。&lt;/p&gt;
&lt;p&gt;SSH_AUTH_SOCK 代表一个 unix domain socket 文件，由 sshd 创建 shell 时指定， 是 ssh-client 和 sshd 做 ssh-agent forwarding 的桥梁；shell 退出时失效； 但是 tmux 在 session 保存了该变量。
当再次 attach 时 （tmux detach, 退出 shell，登录 shell， tmux attach), tmux session 中保存的 SSH_AUTH_SOCK 还是第一次登录时 sshd 分配的，已经失效，应该使用当前登录 shell 环境变量中保存的值。&lt;/p&gt;
&lt;p&gt;但是 tmux 的 update-environment 和 set-environment 在 attach session 好像不会生效，即使重新 load 配置文件也
没有效果。暂时只能采用 &lt;a class="reference external" href="http://unix.stackexchange.com/questions/75681/why-do-i-have-to-re-set-env-vars-in-tmux-when-i-re-attach"&gt;stackexchange&lt;/a&gt; 的方案。&lt;/p&gt;&lt;/div&gt;</description><category>develop tools</category><guid>http://blog.runxcode.com/posts/tmux.html</guid><pubDate>Fri, 04 Dec 2015 15:29:38 GMT</pubDate></item><item><title>gcc 常用实例</title><link>http://blog.runxcode.com/posts/gcc.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;div class="section" id="id1"&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://gcc.gnu.org/"&gt;GCC&lt;/a&gt; (the GNU Compiler Collection) 是由GNU组织开发的编译器套件, 可以执行预处理,编译,汇编和链接动作. 这篇文章首先向大家介绍如何生成C语言的可执行文件, 共享库(动态库) 以及静态库, 然后介绍一下gcc常用的选项.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;例子&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;以下的例子都在Ubuntu13.10 上使用gcc 4.8.1 测试通过. 假设有三个文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;main.c 定义main函数&lt;/li&gt;
&lt;li&gt;a.c 定义add 函数&lt;/li&gt;
&lt;li&gt;b.c 定义sub 函数&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;可执行文件&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;gcc -o test main.c a.c b.c&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;共享库&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;生成共享库&lt;/dt&gt;
&lt;dd&gt;gcc -shared -o libmymath.so a.c b.c&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;使用共享库&lt;/dt&gt;
&lt;dd&gt;gcc -o test main.c -L. -lmymath&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;静态库&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;生成静态库&lt;/dt&gt;
&lt;dd&gt;&lt;ol class="first last arabic"&gt;
&lt;li&gt;gcc -c a.c b.c&lt;/li&gt;
&lt;li&gt;ar crv libmymath.a a.o b.o&lt;/li&gt;
&lt;/ol&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;使用静态库&lt;/dt&gt;
&lt;dd&gt;gcc -o test main.c -static -L. -lmymath&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;注意: 当ld的搜索默认搜索路径即包含共享库又包含静态库时, 默认选择链接共享库；若需要链接静态库, 则需要加上-static选项&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;选项&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;-I(大写的i) 添加路径到预处理器的搜索目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;使用方法 -IPATH&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;gcc -I. -o test main.c a.c b.c&lt;/li&gt;
&lt;li&gt;gcc -I/home/tony/work/myheaer -o test main.c&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;注意: 在搜索头文件时, 通过-I添加的目录会优先与系统默认的搜索目录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;-D 预定义宏&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;p class="first"&gt;使用方法 -DNAME&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;gcc -DCONFIG_GATE -o test main.c&lt;/dt&gt;
&lt;dd&gt;等同于: #define CONFIG_GATE=1&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;gcc -DCONFIG_GATE_VALUE=128 -o test main.c&lt;/dt&gt;
&lt;dd&gt;等同于: #define CONFIG_GATE_VALU=128&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;-c 执行编译和汇编, 但不执行链接动作, 生成中间文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;gcc -c main.c a.c b.c&lt;/li&gt;
&lt;li&gt;生成 main.o, a.o, b.o&lt;/li&gt;
&lt;li&gt;gcc -c main.s a.s b.s&lt;/li&gt;
&lt;li&gt;生成 main.o, a.o, b.o&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;-S 执行编译动作, 但不执行汇编, 生成汇编文件, 通常文件后缀为.s&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;gcc -S main.c a.c b.c&lt;/li&gt;
&lt;li&gt;生成 main.s, a.s, b.s&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;-L 添加路径到链接器的搜索目录&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;gcc -o test main.c -L.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;-l(小写的L) 在指定的library中查找符号表&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;gcc -o test main.c -L. -lmypath&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;-Wall 打开所有的编译警告&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;gcc -Wall -o test main.c&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;-static 优先选择链接静态库&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;gcc -o test main.c -static -L. -lmymath&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;-shared 生成的目标为共享库&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;gcc -shared -o libmymath.so a.c b.c&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;-o 指定生成目标的名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;-Wl 传递参数给链接器&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;gcc -o test main.c -Wl,-Map=out.map -L. -lmymath&lt;/li&gt;
&lt;li&gt;gcc -o test main.c -Wl,-rpath=/media/code/exercise/gcc -L. -lmymath&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;rpath 的作用是添加目录到运行时共享库搜索路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;-g 生成debugging信息, 在使用debug工具比如GCB的时候需要&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;gcc -g -o test main.c a.c .bc&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2&gt;结束语&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然gcc是一个非常强大的工具, 但当一个工程比较庞大是, 直接使用gcc是不明智的选择.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于中等规模的工程,使用makefile来管理是一个不错的选择&lt;/li&gt;
&lt;li&gt;但对于非常庞大的工程, 比如KDE, 可以使用更高阶的管理工具, 比如 &lt;a class="reference external" href="http://www.cmake.org/"&gt;CMake&lt;/a&gt; , &lt;a class="reference external" href="http://www.gnu.org/software/automake/"&gt;automake&lt;/a&gt; 以及 &lt;a class="reference external" href="http://scons.org/"&gt;Scons&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>develop tools</category><guid>http://blog.runxcode.com/posts/gcc.html</guid><pubDate>Sun, 22 Mar 2015 14:10:59 GMT</pubDate></item><item><title>git 常用实例</title><link>http://blog.runxcode.com/posts/git.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;div&gt;&lt;div class="section" id="clone-and-checkout"&gt;
&lt;h2&gt;Clone and Checkout&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;clone远程仓库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;匿名clone&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone &lt;a class="reference external" href="https://github.com/TonyNie/multiplication.git"&gt;https://github.com/TonyNie/multiplication.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;git 协议克隆&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone &lt;a class="reference external" href="mailto:git@github.com"&gt;git@github.com&lt;/a&gt;:TonyNie/multiplication.git&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;https协议克隆&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone &lt;a class="reference external" href="https://tony_nie@bitbucket.org/tony_nie/open-stunclient.git"&gt;https://tony_nie@bitbucket.org/tony_nie/open-stunclient.git&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;删除远程分支&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;git push origin --delete branchname&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="tag"&gt;
&lt;h2&gt;Tag&lt;/h2&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建轻量级TAG&lt;/p&gt;
&lt;p&gt;git tag v-0.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;创建有附注的标签&lt;/p&gt;
&lt;p&gt;git tag -a v3.8rc -m "RC 3.8"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;创建带签名的标签&lt;/p&gt;
&lt;p&gt;git tag -s v3.8rc -m "RC 3.8"&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;将标签v3.8rc推送到远程仓库orgin&lt;/p&gt;
&lt;p&gt;git push origin v3.8rc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;将本地所有的标签都推送到远程仓库origin&lt;/p&gt;
&lt;p&gt;git push origin --tags&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;将标签v3.8rc 检出&lt;/p&gt;
&lt;p&gt;git checkcout -b NEWBRANCH v3.8rc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;删除本地标签v0.1&lt;/p&gt;
&lt;p&gt;git tag -d v0.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;删除远程仓库上的标签k1.2.0&lt;/p&gt;
&lt;p&gt;git push origin --delete tag k1.2.0&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="revert"&gt;
&lt;h2&gt;Revert&lt;/h2&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>develop tools</category><guid>http://blog.runxcode.com/posts/git.html</guid><pubDate>Sat, 14 Feb 2015 12:43:10 GMT</pubDate></item><item><title>ssh 基本用法</title><link>http://blog.runxcode.com/posts/ssh.html</link><dc:creator>Tony Nie</dc:creator><description>&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;本地代理&lt;/p&gt;
&lt;p&gt;ssh -qTfnN -D 7070 -p &lt;em&gt;SSHD_PORT&lt;/em&gt; &lt;a class="reference external" href="mailto:yourname@server"&gt;yourname@server&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ssh -A&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><category>develop tools</category><guid>http://blog.runxcode.com/posts/ssh.html</guid><pubDate>Wed, 24 Sep 2014 14:42:08 GMT</pubDate></item></channel></rss>